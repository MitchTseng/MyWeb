<% include _header %>
<div  style="width: 100%;">
<div class="container-fluid">
<div style="display: inline-block; margin-top: 5%;">
    <table class = "table"  style="margin-top: 5%;">
    	<th style="background-color: #A1E2A2">
    	<h2>Water Fall Algorithm</h2>
    	<p style="text-align: right;">2014</p>
		</th>
		<tr>
			<td>
				<img src = "img/a1.jpg" class = "photo img-responsive col-sm-6">
				<p style="text-align: left; font-size: 21px;" class = "col-sm-6"> 
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Water Fall Algorithm use the concept like Watershed algorithm, seeing the 1-D or 2-D data as real complicated terrain area. Water Fall Algorithm can find the local minimum efficiently. I develop this algorithm by myself.
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p style="text-align: left; font-size: 21px;" class = "col-sm-6"> 
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;First, assign two parameters. One is the volume of water and the other one is step, which means how far the water could move.<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Second, let the water fall on every points of the data, and then calculate every point where the water will move repeatly.
				</p>
				<img src = "img/a2.jpg" class = "photo img-responsive col-sm-6">
			</td>
		</tr>
		<tr>
			<td>
				<img src = "img/a3.jpg" class = "photo img-responsive col-sm-6">
				<p style="text-align: left; font-size: 21px;" class = "col-sm-6"> 
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When the number of calculating times equal to the parameter step, use an auto-thresholding algorithm like the Otsu method to define a threshold to judge which points are local minimum.
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p style="text-align: left; font-size: 21px;" class = "col-sm-6"> 
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This algorithm also can be used to find the object's edges. Because the edges is one of the local minimum when the step is not too high. In 1-D and 2-D data, this algorithm is useful to find local minimum and edges.<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The advantage of this algorithm is that it can find out the non-obvious edges in images. On the other hand, the disadvantage of this algorithm is also that it will find out every non-obvious edge in images, and it sometimes will let users difficultly choose the parts they want of images.
				</p>
				<img src = "img/a4.jpg" class = "photo img-responsive col-sm-6">
			</td>
		</tr>

		<th style="background-color: #A1E2A2">
    	<h2>Digital Image Correlation</h2>
    	<p style="text-align: right;">2014-2015</p>
		</th>
		<tr>
			<td>
				<img src = "img/a5.jpg" class = "photo img-responsive col-sm-6">
				<p style="text-align: left; font-size: 21px;" class = "col-sm-6"> 
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Digital image correlation is a general method to recognize features of images. When we use a bigger subset , like 31x31, and the amount of the images is more than several decades, it will cost much time and then can not be used in real-time application.
				</p>
			</td>
		</tr>
		<tr>
			<td>
				<p style="text-align: left; font-size: 21px;" class = "col-sm-6"> 
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I develop a fast version of the digital image correlation. When the amount of images is fifty, the size of each image is 1024 x 768, the subset size is 61x61 and shift 6 pixels every time to calculate the result, it cost about 0.2 second on average to calculate the result by using only one thread.<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Normally, when the system use the method in OpenCV with some speed up skills and the code is written in C/C++, it will cost about 5 seconds to calculate the result in the same situation, even it uses parallel computing in an eight-core CPU.<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; But the original method can let the result has high quality even when the object has curvature surface. The disadvantage of my algorithm is that the result can not have high quality when the object has curvature surface.
				</p>
				<img src = "img/a6.jpg" class = "photo img-responsive col-sm-6">
			</td>
		</tr>
		<tr>
			<td>
				<img src = "img/a7.jpg" class = "photo img-responsive col-sm-6">
				<p style="text-align: left; font-size: 21px;" class = "col-sm-6"> 
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This algorithm can speed up the process for calculating the height information in 3-D measurement applications. Because of the speed, it's suitable for embedded systems like automated machine tools and compact sensors.<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I develop the core concept for making the digital image correlation fast and all the code of this algorithm by myself. This algorithm is written in C and builded as a Python module. The Python module also contains the functions used to read images and display 3-D images written by me to let this module can work without other additional modules and ensure the efficiency. Because the code for this algorithm is written in C and has high completeness, it can be applied in many system immediately.<br>
				</p>
			</td>
		</tr>
	</table>

</div>
</div>
</div>
<div id="space" style="height: 60px"></div>
<% include _footer %>
